<html>
    <head>
    </head>

    <body>
        <script src="lib/twgl/twgl-full.min.js"></script>
        
        <script src="src/sowebplot.js"></script>
        <div id="sowebplot-target" style="border: 1px black solid; width:512px; height:512px;">
            
        </div>
        <script>
            document.addEventListener("DOMContentLoaded", (d, e) =>
            {
                var plotter = new SoWebPlotter("sowebplot-target");

                var gl = plotter.webgl;

                // Todo: check...
                gl.getExtension("OES_standard_derivatives");

                let plot = new R2toRPlot(new RealValuedFunction(["x", "y"], "Math.cos(5 * x) * 2 - Math.sin(3 * y)"));
                let bounds = {
                        "min": twgl.v3.create(-1.5, -1.5, -1.5),
                        "max": twgl.v3.create( 1.5,  1.5,  1.5)
                    };
                let geo = plot.calculateSurface(
                    bounds,
                    null
                );

                let ground = twgl.createBufferInfoFromArrays(gl, {
                    "position": {"numComponents": 3, "data": [-1, 0, -1,  1, 0, -1,  1, 0, 1,  -1, 0, 1] },
                    "indices": {"numComponents": 3, "data": [0, 1, 3, 1, 2, 3] },
                    "normal": {"numComponents": 3, "data": [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0] }
                });
                let buffers = twgl.createBufferInfoFromArrays(gl, geo);

                let prog = twgl.createProgramInfo(
                    gl, 
                    [
                        [
                            "attribute vec3 position;",
                            "attribute vec3 normal;",
                            "attribute float value;",
                            "varying vec3 vNormal;",
                            "varying vec3 vPosition;",
                            "varying float vValue;",
                            "varying vec3 vEye;",
                            "uniform mat4 view;",
                            "uniform mat4 model;",
                            "uniform mat4 proj;",
                            "void main() {",
                            "   vEye = (view * model * vec4(0, 0, -1, 1)).xyz;",
                            "   gl_Position = proj * view * model * vec4(position, 1);",
                            "   vNormal = normal; vPosition = position; vValue = value;",
                            "}"
                        ].join("\n"),
                        [
                            "#extension GL_OES_standard_derivatives : enable",
                            "precision mediump float;",
                            "varying vec3 vPosition;",
                            "varying vec3 vNormal;",
                            "varying float vValue;",
                            "varying vec3 vEye;",
                            "uniform vec3 boundsMin;",
                            "uniform vec3 boundsMax;",
                            "const vec3 COLOUR_MIN = vec3(0.043, 0.475, 0.576);",
                            "const vec3 COLOUR_MAX = vec3(0.933, 0.486, 0.047);",
                            "void main() { ",
                            "   vec3 N = normalize(vNormal); vec3 I = normalize(vEye);",
                            "   float ywidth = abs(boundsMax.y - boundsMin.y);",
                            "   float yderiv = fwidth(vPosition.y);",
                            "   float ymod =  mod(vPosition.y, 0.25);",
                            "   if (vPosition.y < boundsMin.y || vPosition.y > boundsMax.y) discard; ",
                            "   gl_FragColor = vec4(mix(0.2, 1.0, abs(dot(N, I))) * mix(COLOUR_MIN, COLOUR_MAX, vValue) * step(yderiv, ymod), 1);",
                            "}"
                        ].join("\n"),
                    ]);
                
                function calculateViewMat() {
                    let pos = twgl.v3.create(1, 1, 1);
                    let move = twgl.m4.lookAt(pos, twgl.v3.create(0, 0, 0), twgl.v3.create(0, 1, 0));
                    return twgl.m4.inverse(move);
                    //return twgl.m4.identity();
                }

                function calculateModelMat(time) {
                    let modelMat = twgl.m4.translation(twgl.v3.create(0, -0.0, 0));
                    return twgl.m4.rotateY(modelMat, Math.PI * 0.0001 * time);  
                }

                function calculateProjMat() {
                    let projMat = twgl.m4.ortho(-2, 2, -2, 2, 0.01, 100);
                    return projMat;
                }

                               
                gl.clearColor(0, 0, 0, 1);
                gl.frontFace(gl.CCW);
                //gl.disable(gl.CULL_FACE);              
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
                

                function render(time) {
                    twgl.resizeCanvasToDisplaySize(gl.canvas);

                    let uniforms = {
                        view: calculateViewMat(time),
                        model: calculateModelMat(time),
                        proj: calculateProjMat(time),
                        boundsMin: bounds.min,
                        boundsMax: bounds.max
                    };

                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                    gl.enable(gl.STENCIL_TEST);
                    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                    gl.useProgram(prog.program);
                    twgl.setUniforms(prog, uniforms);

                    //gl.colorMask(false, false, false, false);
                    //gl.depthMask(true);
//
                    //gl.stencilFunc(gl.ALWAYS, 1,  255);
                    //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                    //gl.stencilMask(255);
//
                    //twgl.setBuffersAndAttributes(gl, prog, buffers);
                    //twgl.drawBufferInfo(gl, buffers);
//
                    //gl.stencilOp(gl.KEEP, gl.ZERO, gl.REPLACE);
                    //gl.stencilMask(255);
//
                    //twgl.setBuffersAndAttributes(gl, prog, ground);
                    //twgl.drawBufferInfo(gl, ground);
//
                    //gl.colorMask(true, true, true, true);
                    //gl.depthMask(true);
                    //gl.stencilFunc(gl.GEQUAL, 1,  255);
                    //gl.stencilMask(0);
                    
                    twgl.setBuffersAndAttributes(gl, prog, buffers);
                    twgl.drawBufferInfo(gl, buffers);
                    twgl.setBuffersAndAttributes(gl, prog, ground);
                    twgl.drawBufferInfo(gl, ground);
                    gl.disable(gl.STENCIL_TEST);
                   
                    requestAnimationFrame(render);
                }
                requestAnimationFrame(render);
            });            
        </script>
    </body>
</html>